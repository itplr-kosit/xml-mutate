// Generated by delombok at Fri Aug 13 16:11:22 CEST 2021
package de.init.kosit.commons.validate;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.io.Reader;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.xml.transform.Source;
import javax.xml.transform.stream.StreamSource;
import javax.xml.validation.Schema;
import javax.xml.validation.SchemaFactory;

import org.w3c.dom.ls.LSInput;
import org.w3c.dom.ls.LSResourceResolver;
import org.xml.sax.SAXException;

import de.init.kosit.commons.ObjectFactory;
import de.init.kosit.commons.artefact.Artefact;

/**
 * Repository for loading and caching schema instances.
 *
 * @author Andreas Penski (]init[ AG)
 */
public class SchemaRepository {
    private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(SchemaRepository.class);

    private static final class MyLSInput implements LSInput {
        private String baseURI;
        private InputStream byteStream;
        private String encoding;
        private String publicId;
        private String systemId;

        MyLSInput(final String publicId, final String systemId, final String baseURI, final ByteArrayInputStream byteArrayInputStream, final String encoding) {
            setPublicId(publicId);
            setSystemId(systemId);
            setBaseURI(baseURI);
            setByteStream(byteArrayInputStream);
            setEncoding(encoding);
        }

        @Override
        public boolean getCertifiedText() {
            return false;
        }

        @Override
        public void setCertifiedText(final boolean certifiedText) {
            // nothing to set
        }

        @Override
        public Reader getCharacterStream() {
            return null;
        }

        @Override
        public void setCharacterStream(final Reader characterStream) {
            // nothing to set
        }

        @Override
        public String getStringData() {
            return null;
        }

        @Override
        public void setStringData(final String stringData) {
            // nothing to set
        }

        public String getBaseURI() {
            return this.baseURI;
        }

        public InputStream getByteStream() {
            return this.byteStream;
        }

        public String getEncoding() {
            return this.encoding;
        }

        public String getPublicId() {
            return this.publicId;
        }

        public String getSystemId() {
            return this.systemId;
        }

        public void setBaseURI(final String baseURI) {
            this.baseURI = baseURI;
        }

        public void setByteStream(final InputStream byteStream) {
            this.byteStream = byteStream;
        }

        public void setEncoding(final String encoding) {
            this.encoding = encoding;
        }

        public void setPublicId(final String publicId) {
            this.publicId = publicId;
        }

        public void setSystemId(final String systemId) {
            this.systemId = systemId;
        }
    }


    private class MySchemaResolver implements LSResourceResolver {
        Map<String, byte[]> resolve = new HashMap<>();

        MySchemaResolver(final List<Artefact> schemaArtefacts) {
            schemaArtefacts.forEach(a -> this.resolve.put(a.getName(), a.getContent()));
        }

        @Override
        public LSInput resolveResource(final String type, final String namespaceURI, final String publicId, final String systemId, final String baseURI) {
            return new MyLSInput(publicId, systemId, baseURI, new ByteArrayInputStream(this.resolve.get(systemId)), "UTF-8");
        }
    }

    private final Map<URI, Schema> cache = new HashMap<>();

    private static Schema createSchema(final Source[] schemaSources, final LSResourceResolver resourceResolver) {
        try {
            final SchemaFactory sf = ObjectFactory.createSchemaFactory();
            sf.setResourceResolver(resourceResolver);
            return sf.newSchema(schemaSources);
        } catch (final SAXException e) {
            throw new IllegalArgumentException("Can not load schema from sources " + schemaSources[0].getSystemId(), e);
        }
    }

    /**
     * Creates a new schema instances based on the provides information.
     *
     * @param url the base url of the schema
     * @param resolver an optional resolver
     * @return a new created schema instance
     */
    public Schema createSchema(final URI url, final LSResourceResolver resolver) {
        log.info("Load schema from source {}", url.getPath());
        return createSchema(new Source[] {resolve(url)}, resolver);
    }

    /**
     * Creates a new schema instances based on the provides information.
     *
     * @param url the base url of the schema
     * @return a new created schema instance
     */
    public Schema createSchema(final URI url) {
        return createSchema(url, null);
    }

    /**
     * Returns a schema that corresponds to the given URL. Return a maybe previously created (shared) instance.
     *
     * @param schemaResource the url of the schema
     * @param resolver an optional resolver for creating the schema.
     * @return a maybe cached schema instance
     */
    public Schema getSchema(final URL schemaResource, final LSResourceResolver resolver) {
        try {
            return createSchema(schemaResource.toURI(), resolver);
        } catch (final URISyntaxException e) {
            throw new IllegalArgumentException(String.format("Not a valid uri %s", schemaResource));
        }
    }

    /**
     * Returns a schema that corresponds to the given URL. Return a maybe previously created (shared) instance.
     *
     * @param uri the url of the schema
     * @param resolver an optional resolver for creating the schema.
     * @return a maybe cached schema instance
     */
    public Schema getSchema(final URI uri, final LSResourceResolver resolver) {
        Schema schema = this.cache.get(uri);
        if (schema == null) {
            schema = createSchema(uri, resolver);
            this.cache.put(uri, schema);
        }
        return schema;
    }

    /**
     * Returns a schema that corresponds to the given URL. Return a maybe previously created (shared) instance.
     *
     * @param def the uri of the schema
     * @return a maybe cached schema instance
     */
    public Schema getSchema(final String def) {
        return getSchema(URI.create(def), null);
    }

    private Source resolve(final URI source) {
        return new StreamSource(source.toASCIIString());
    }

    private Source resolve(final byte[] source) {
        return new StreamSource(new ByteArrayInputStream(source));
    }

    public Schema getSchema(final Artefact main, final List<Artefact> artefacts) {
        Schema schema = this.cache.get(main.getUri());
        if (schema == null) {
            schema = createSchema(new Source[] {resolve(main.getContent())}, new MySchemaResolver(artefacts));
            this.cache.put(main.getUri(), schema);
        }
        return schema;
    }
}
