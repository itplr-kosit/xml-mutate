// Generated by delombok at Fri Aug 13 16:11:22 CEST 2021
package de.init.kosit.commons.validate;

import java.io.IOException;

import javax.xml.XMLConstants;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.util.JAXBSource;
import javax.xml.transform.dom.DOMSource;
import javax.xml.validation.Schema;
import javax.xml.validation.Validator;

import org.w3c.dom.Document;
import org.xml.sax.SAXException;
import org.xml.sax.SAXNotRecognizedException;
import org.xml.sax.SAXNotSupportedException;

import de.init.kosit.commons.CollectingErrorEventHandler;
import de.init.kosit.commons.Result;
import de.init.kosit.commons.SyntaxError;
import de.init.kosit.commons.convert.ConversionService;
import de.init.kosit.commons.util.BusinessError;
import de.init.kosit.commons.util.CommonException;

/**
 * Service Klasse zur Validierung der XML-Datein(als Artefact) mithilfe der Schema-Dateien(als Artefact).
 *
 * @author ooezpehlivan
 */
public class SchemaValidationService {
    private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(SchemaValidationService.class);

    private final ConversionService conversionService;

    public SchemaValidationService(final ConversionService conversionService) {
        this.conversionService = conversionService;
    }

    /**
     * Validiert die XML-Datei gegen gegebenen Schema-Dateien.
     *
     * @param schema das Schema
     * @param xml Zu validierende Datei.
     * @return result
     */
    public Result<Boolean, SyntaxError> validate(final Schema schema, final byte[] xml) {
        return validate(schema, this.conversionService.parseDocument(xml).getObject());
    }

    public Result<Boolean, SyntaxError> validate(final Schema schema, final Document document) {
        final CollectingErrorEventHandler errorHandler = new CollectingErrorEventHandler();
        try {
            final Validator validator = createValidator(schema);
            validator.setErrorHandler(errorHandler);
            validator.validate(new DOMSource(document));
            return new Result<>(!errorHandler.hasErrors(), errorHandler.getErrors());
        } catch (final SAXException | IOException e) {
            throw new CommonException(new BusinessError(ErrorCode.VALIDATION_ERROR), e);
        }
    }

    /**
     * Validiert ein Java-Objekt nach einem definierten Schema. Nutzt hierzu den globalen JAXB-Context.
     *
     * @param schema das Schema
     * @param objekt das Objekt das validiert werden soll
     * @param <T> der Typ des Objekts
     * @return Validierungsergebnis
     */
    public <T> Result<Boolean, SyntaxError> validate(final Schema schema, final T objekt) {
        if (byte[].class.isAssignableFrom(objekt.getClass())) {
            return validate(schema, (byte[]) objekt);
        }
        if (Document.class.isAssignableFrom(objekt.getClass())) {
            return validate(schema, (Document) objekt);
        }
        return validate(schema, conversionService.getJaxbContext(), objekt);
    }

    /**
     * Validiert ein Java-Objekt nach einem definierten Schema. Nutzt hierzu den Ã¼bergebenen JAXB-Context.
     *
     * @param schema das Schema
     * @param objekt das Objekt das validiert werden soll
     * @param <T> der Typ des Objekts
     * @return Validierungsergebnis
     */
    public <T> Result<Boolean, SyntaxError> validate(final Schema schema, final JAXBContext context, final T objekt) {
        final CollectingErrorEventHandler errorHandler = new CollectingErrorEventHandler();
        try {
            final Validator validator = createValidator(schema);
            validator.setErrorHandler(errorHandler);
            final JAXBSource js = new JAXBSource(context, objekt);
            validator.validate(js);
            return new Result<>(!errorHandler.hasErrors(), errorHandler.getErrors());
        } catch (final SAXException | IOException | JAXBException e) {
            throw new CommonException(new BusinessError(ErrorCode.VALIDATION_ERROR), e);
        }
    }

    private Validator createValidator(final Schema schema) {
        final Validator validator = schema.newValidator();
        try {
            validator.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, "");
        } catch (final SAXNotRecognizedException | SAXNotSupportedException e) {
            log.warn("Can not disable external DTD access. Maybe an unsupported JAXP implementation is used.");
            log.debug(e.getMessage(), e);
        }
        try {
            validator.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, "");
        } catch (final SAXNotRecognizedException | SAXNotSupportedException e) {
            log.warn("Can not disable external DTD access. Maybe an unsupported JAXP implementation is used.");
            log.debug(e.getMessage(), e);
        }
        return validator;
    }
}
