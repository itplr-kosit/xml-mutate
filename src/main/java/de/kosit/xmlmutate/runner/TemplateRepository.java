// Generated by delombok at Fri Aug 13 16:07:39 CEST 2021
package de.kosit.xmlmutate.runner;

import static org.apache.commons.lang3.StringUtils.isEmpty;
import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.file.Path;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import javax.xml.XMLConstants;
import javax.xml.transform.Templates;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.stream.StreamSource;
import org.apache.commons.collections4.map.HashedMap;
import de.kosit.xmlmutate.mutation.NamedTemplate;

/**
 * Repository for caching an XSLT Template for reuse.
 * 
 * @author Andreas Penski
 */
public class TemplateRepository {
    @java.lang.SuppressWarnings("all")
    private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(TemplateRepository.class);


    private class TemplateAndPath {
        private final Templates template;
        private final URI path;

        @java.lang.SuppressWarnings("all")
        public TemplateAndPath(final Templates template, final URI path) {
            this.template = template;
            this.path = path;
        }

        @java.lang.SuppressWarnings("all")
        public Templates getTemplate() {
            return this.template;
        }

        @java.lang.SuppressWarnings("all")
        public URI getPath() {
            return this.path;
        }
    }

    private final TransformerFactory factory;
    private final Map<String, TemplateAndPath> templates = new HashedMap<>();

    /**
     * Constructor.
     */
    public TemplateRepository() {
        try {
            this.factory = TransformerFactory.newInstance();
            this.factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
        } catch (final TransformerConfigurationException e) {
            throw new IllegalStateException("Can not prepare Template repository.", e);
        }
    }

    /**
     * Determine whether a named template exists or not.
     * 
     * @param name the name of the template
     * @return true if existing
     */
    public boolean exists(final String name) {
        return this.templates.get(name) != null;
    }

    /**
     * Fetch a template from the cache.
     * 
     * @param name the name of the template
     * @return the compiled template or null if it is not existing
     */
    public Templates getTemplate(final String name) {
        return exists(name) ? this.templates.get(name).getTemplate() : null;
    }

    /**
     * Register a new template and try to compile it for further usage.
     * 
     * @param name the name of the template
     * @param uri the uri of the resource
     */
    public void registerTemplate(final String name, final URL uri) {
        checkArguments(name, uri);
        try (InputStream in = uri.openStream()) {
            final Templates t = this.factory.newTemplates(new StreamSource(in));
            this.templates.put(name, new TemplateAndPath(t, uri.toURI()));
        } catch (final IOException | TransformerConfigurationException | URISyntaxException e) {
            throw new IllegalArgumentException(String.format("Can not compile xslt template %s from %s", name, uri.toString()));
        }
    }

    private void checkArguments(final String name, final Object uri) {
        if (isEmpty(name) || uri == null) {
            throw new IllegalArgumentException("Can not register template. Unsufficient information supplied");
        }
        if (this.templates.get(name) != null) {
            throw new IllegalArgumentException("Can not register template twice: " + name);
        }
    }

    /**
     * Removes previously registered templates. Mainly for testing purposes.
     */
    public void clear() {
        this.templates.clear();
    }

    /**
     * Register a new template and try to compile it for further usage.
     *
     * @param name the name of the template
     * @param uri the uri of the resource
     */
    public void registerTemplate(final String name, final URI uri) {
        checkArguments(name, uri);
        try {
            registerTemplate(name, uri.toURL());
        } catch (final MalformedURLException e) {
            throw new IllegalArgumentException(String.format("Can not compile xslt template %s from %s", name, uri.toString()));
        }
    }

    /**
     * Register a new template and try to compile it for further usage.
     * 
     * @param name the name of the template
     * @param path the {@link Path} to the resource
     */
    public void registerTemplate(final String name, final Path path) {
        registerTemplate(name, path.toUri());
    }

    /**
     * Checks for existing template.
     * 
     * @param name the name/uri of the template
     * @return true when existing.
     */
    public boolean contains(final String name) {
        return exists(name);
    }

    /**
     * Checks for not existing template.
     * 
     * @param name the name/uri of the template
     * @return true when NOT existing.
     */
    public boolean doesNotContain(final String name) {
        return !contains(name);
    }

    /**
     * Returns a list of registered and compiled Templates (just information, not the {@link Templates} themselves)
     * 
     * @return List of templates.
     */
    public List<NamedTemplate> getTemplates() {
        return this.templates.entrySet().stream().map(e -> new NamedTemplate(e.getKey(), e.getValue().getPath())).collect(Collectors.toList());
    }
}
