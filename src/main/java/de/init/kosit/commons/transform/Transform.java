// Generated by delombok at Fri Aug 13 16:11:22 CEST 2021
package de.init.kosit.commons.transform;

import java.util.HashMap;
import java.util.Map;

import javax.xml.bind.Unmarshaller;
import javax.xml.transform.URIResolver;
import javax.xml.validation.Schema;

import de.init.kosit.commons.Result;
import net.sf.saxon.s9api.QName;
import net.sf.saxon.s9api.XdmValue;
import net.sf.saxon.s9api.XsltExecutable;

/**
 * Konfigurationsobjekt f端r eine auszuf端hrende Transformation.
 *
 * @author Andreas Penski (]init[ AG)
 */
public class Transform<T> {

    /**
     * Builder f端r das Erstellen einer Transformations-Konfiguration.
     *
     * @param <T> der Zieltyp der Transformation
     */
    public static class Builder<T> {
        private Transform<T> object = new Transform<>();

        private Builder(final XsltExecutable executable) {
            getObject().setExecutable(executable);
        }

        public Builder(final Transform<T> object) {
            this.object = object;
        }

        protected Transform<T> getObject() {
            return this.object;
        }

        /**
         * Konvertiert optional das Ergebnis in ein Zielobjekt.
         *
         * @param newType der Klasse des Zielobjekts
         * @param <N> der Typ des Zielobjekts
         * @return this
         */
        public <N> Builder<N> convertTo(final Class<N> newType) {
            getObject().setTargetType((Class<T>) newType);
            return (Builder<N>) this;
        }

        public Builder<T> validate(final Schema schema) {
            getObject().setSchema(schema);
            return this;
        }

        public Builder<T> addListener(final Unmarshaller.Listener listener) {
            getObject().setUnmarshListener(listener);
            return this;
        }

        public Builder<T> withParams(final Map<QName, XdmValue> params) {
            this.getObject().setParameters(params);
            return this;
        }

        public Builder<T> useResult(final Result result) {
            this.getObject().setResult(result);
            return this;
        }

        public Builder<T> useResolver(final URIResolver resolver) {
            this.getObject().setResolver(resolver);
            return this;
        }

        public Transform<T> build() {
            return getObject();
        }
    }

    private Schema schema;
    private XsltExecutable executable;
    private Class<T> targetType;
    private Map<QName, XdmValue> parameters = new HashMap<>();
    private Unmarshaller.Listener unmarshListener;
    private URIResolver resolver;
    private Result result;

    /**
     * Ein XSLT Executable das ausgef端hrt werden soll.
     *
     * @param executable the xslt executable
     * @return a new builder
     */
    public static Builder<byte[]> create(final XsltExecutable executable) {
        return new Builder<>(executable);
    }

    /**
     * Erweitert die bestehenden Transformation um weitere Eigenschaft. Dabei wird eine Kopie erzeugt.
     *
     * @param baseConfiguration Basis
     * @param <T> der Zieltyp der Transformation
     * @return ein neuer Builder
     */
    public static <T> Builder<T> extend(final Transform<T> baseConfiguration) {
        final Transform<T> copy = new Transform<>();
        copy.setSchema(baseConfiguration.getSchema());
        copy.setTargetType(baseConfiguration.getTargetType());
        copy.setExecutable(baseConfiguration.getExecutable());
        copy.setResolver(baseConfiguration.getResolver());
        return new Builder<>(copy);
    }

    public void setSchema(final Schema schema) {
        this.schema = schema;
    }

    public void setExecutable(final XsltExecutable executable) {
        this.executable = executable;
    }

    public void setTargetType(final Class<T> targetType) {
        this.targetType = targetType;
    }

    public void setParameters(final Map<QName, XdmValue> parameters) {
        this.parameters = parameters;
    }

    public void setUnmarshListener(final Unmarshaller.Listener unmarshListener) {
        this.unmarshListener = unmarshListener;
    }

    public void setResolver(final URIResolver resolver) {
        this.resolver = resolver;
    }

    public void setResult(final Result result) {
        this.result = result;
    }

    public Schema getSchema() {
        return this.schema;
    }

    public XsltExecutable getExecutable() {
        return this.executable;
    }

    public Class<T> getTargetType() {
        return this.targetType;
    }

    public Map<QName, XdmValue> getParameters() {
        return this.parameters;
    }

    public Unmarshaller.Listener getUnmarshListener() {
        return this.unmarshListener;
    }

    public URIResolver getResolver() {
        return this.resolver;
    }

    public Result getResult() {
        return this.result;
    }
}
