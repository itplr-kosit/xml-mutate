// Generated by delombok at Fri Aug 13 16:11:22 CEST 2021
/*
 * Copyright (c) 2017. Lorem ipsum dolor sit amet, consectetur adipiscing elit.
 * Morbi non lorem porttitor neque feugiat blandit. Ut vitae ipsum eget quam lacinia accumsan.
 * Etiam sed turpis ac ipsum condimentum fringilla. Maecenas magna.
 * Proin dapibus sapien vel ante. Aliquam erat volutpat. Pellentesque sagittis ligula eget metus.
 * Vestibulum commodo. Ut rhoncus gravida arcu.
 */
package de.init.kosit.commons;

import java.util.ArrayList;
import java.util.List;
import java.util.StringJoiner;
import javax.xml.bind.ValidationEvent;
import javax.xml.bind.ValidationEventHandler;
import javax.xml.bind.ValidationEventLocator;
import javax.xml.transform.ErrorListener;
import javax.xml.transform.SourceLocator;
import javax.xml.transform.TransformerException;
import org.w3c.dom.DOMError;
import org.w3c.dom.DOMErrorHandler;
import org.w3c.dom.DOMLocator;
import org.xml.sax.ErrorHandler;
import org.xml.sax.SAXParseException;
import net.sf.saxon.s9api.MessageListener;
import net.sf.saxon.s9api.XdmNode;

/**
 * Sammelt Validierungs-Ereignisinformation beim Schema-Validieren.
 *
 * @author Andreas Penski (]init[ AG)
 */
public class CollectingErrorEventHandler implements ValidationEventHandler, ErrorHandler, MessageListener, ErrorListener, DOMErrorHandler {
    @java.lang.SuppressWarnings("all")
    private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(CollectingErrorEventHandler.class);
    private static final int DEFAULT_ABORT_COUNT = 50;
    private final List<SyntaxError> errors = new ArrayList<>();
    private final int stopProcessCount = DEFAULT_ABORT_COUNT;

    private static SyntaxError createError(final Severity severity, final String message) {
        final SyntaxError e = new SyntaxError();
        e.setSeverity(severity);
        e.setMessage(message);
        return e;
    }

    private static SyntaxError createError(final Severity severity, final SAXParseException exception) {
        final SyntaxError e = createError(severity, exception.getMessage());
        e.setRowNumber(exception.getLineNumber());
        e.setColumnNumber(exception.getColumnNumber());
        return e;
    }

    private static SyntaxError createError(final Severity severity, final TransformerException exception) {
        final SyntaxError e = createError(severity, exception.getMessage());
        final SourceLocator locator = exception.getLocator();
        if (locator != null) {
            e.setRowNumber(locator.getLineNumber());
            e.setColumnNumber(locator.getColumnNumber());
            e.setSource(locator.getSystemId());
        }
        return e;
    }

    private static Severity translateSeverity(final int severity) {
        switch (severity) {
        case ValidationEvent.WARNING: 
            return Severity.SEVERITY_WARNING;
        case ValidationEvent.ERROR: 
            return Severity.SEVERITY_ERROR;
        case ValidationEvent.FATAL_ERROR: 
            return Severity.SEVERITY_FATAL_ERROR;
        default: 
            throw new IllegalArgumentException("Unknown severity level " + severity);
        }
    }

    @Override
    public boolean handleEvent(final ValidationEvent event) {
        final SyntaxError e = createError(translateSeverity(event.getSeverity()), event.getMessage());
        final ValidationEventLocator locatator = event.getLocator();
        e.setColumnNumber(locatator.getColumnNumber());
        e.setRowNumber(locatator.getLineNumber());
        e.setSource(locatator.getURL() != null ? locatator.getURL().toString() : "");
        this.errors.add(e);
        return this.stopProcessCount != this.errors.size();
    }

    /**
     * Zeigt an, ob Validierungsfehler vorhanden sind.
     *
     * @return true wenn mindestens ein Fehler vorhanden ist.
     */
    public boolean hasErrors() {
        return hasEvents() && this.errors.stream().anyMatch(e -> e.getSeverity() != Severity.SEVERITY_WARNING);
    }

    /**
     * Zeigt an, ob es Validierungs-Ereignisse gab.
     *
     * @return true wenn mindestens ein Validierungsereignis aufgetreten ist
     */
    public boolean hasEvents() {
        return !this.errors.isEmpty();
    }

    @Override
    public void warning(final SAXParseException exception) {
        this.errors.add(createError(Severity.SEVERITY_WARNING, exception));
    }

    @Override
    public void error(final SAXParseException exception) {
        this.errors.add(createError(Severity.SEVERITY_ERROR, exception));
    }

    @Override
    public void fatalError(final SAXParseException exception) {
        this.errors.add(createError(Severity.SEVERITY_FATAL_ERROR, exception));
    }

    @Override
    public void message(final XdmNode content, final boolean terminate, final SourceLocator locator) {
        final SyntaxError e;
        final String errorString;
        if (terminate) {
            e = createError(Severity.SEVERITY_FATAL_ERROR, content.toString());
            errorString = "Transformation error: " + content.toString();
        } else {
            errorString = String.format("Transformation message:  %s", content.toString());
            e = createError(Severity.SEVERITY_WARNING, content.toString());
        }
        e.setColumnNumber(locator.getColumnNumber());
        e.setRowNumber(locator.getLineNumber());
        e.setMessage(errorString);
        e.setSource(locator.getSystemId());
        e.log(log);
        this.errors.add(e);
    }

    @Override
    public void warning(final TransformerException exception) throws TransformerException {
        this.errors.add(createError(Severity.SEVERITY_WARNING, exception));
    }

    @Override
    public void error(final TransformerException exception) throws TransformerException {
        this.errors.add(createError(Severity.SEVERITY_ERROR, exception));
    }

    @Override
    public void fatalError(final TransformerException exception) throws TransformerException {
        this.errors.add(createError(Severity.SEVERITY_FATAL_ERROR, exception));
    }

    /**
     * Gibt eine lesbare FM zurÃ¼ck.
     * 
     * @return FM
     */
    public String getErrorDescription() {
        final StringJoiner joiner = new StringJoiner("\n");
        final SyntaxError e = this.errors.iterator().next();
        joiner.add(e.getSeverity().name() + " " + e.getMessage() + "\nIn " + e.getSource() + " at row " + e.getRowNumber() + " at pos " + e.getColumnNumber());
        final StringBuilder msg = new StringBuilder(joiner.toString());
        if (this.errors.size() > 1) {
            msg.append(" und weitere " + Integer.toString(this.errors.size() - 1) + " Fehler");
        }
        return msg.toString().replaceAll("\\$", "");
    }

    @Override
    public boolean handleError(final DOMError error) {
        final SyntaxError e = new SyntaxError();
        final DOMLocator location = error.getLocation();
        if (location != null) {
            e.setRowNumber(location.getLineNumber());
            e.setColumnNumber(location.getColumnNumber());
            e.setSource(location.getUri() != null ? location.getUri() : "");
        }
        e.setMessage(error.getMessage());
        // DOMError constants are 1 based, ValidationEvent constants are 0 based
        e.setSeverity(translateSeverity(error.getSeverity() - 1));
        getErrors().add(e);
        return true;
    }

    @java.lang.SuppressWarnings("all")
    public List<SyntaxError> getErrors() {
        return this.errors;
    }

    @java.lang.SuppressWarnings("all")
    public int getStopProcessCount() {
        return this.stopProcessCount;
    }
}
