// Generated by delombok at Fri Aug 13 16:11:22 CEST 2021
package de.init.kosit.commons.transform;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import javax.xml.transform.Source;
import javax.xml.transform.URIResolver;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamSource;

import org.w3c.dom.Document;

import de.init.kosit.commons.CollectingErrorEventHandler;
import de.init.kosit.commons.Result;
import de.init.kosit.commons.Severity;
import de.init.kosit.commons.SyntaxError;
import de.init.kosit.commons.convert.ConversionService;
import de.init.kosit.commons.normalize.Model;
import de.init.kosit.commons.util.BusinessError;
import de.init.kosit.commons.util.CommonException;
import de.init.kosit.commons.validate.SchemaValidationService;
import net.sf.saxon.s9api.DocumentBuilder;
import net.sf.saxon.s9api.Processor;
import net.sf.saxon.s9api.QName;
import net.sf.saxon.s9api.SaxonApiException;
import net.sf.saxon.s9api.XdmNode;
import net.sf.saxon.s9api.XdmValue;
import net.sf.saxon.s9api.XsltExecutable;
import net.sf.saxon.s9api.XsltTransformer;

/**
 * Service Klasse zum transformieren der angegebenen XML-Dateien (als Artefact) mithilfe der XSLT-Dateien(als Artefact).
 *
 * @author ooezpehlivan
 * @author apenski
 */
//@ApplicationScoped
public class TransformationService {
    @java.lang.SuppressWarnings("all")
    private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(TransformationService.class);


    private class Messages {
    }

    //@Inject
    private ConversionService conversionService;
    //@Inject
    private SchemaValidationService schemaValidationService;
    //@Inject
    private ExecutableRepository repository;
    //@Inject
    private Processor processor;

    public Result<byte[], SyntaxError> transform(final URI uri, final Model model) {
        return transform(uri, null, model);
    }

    public Result<byte[], SyntaxError> transform(final URI uri, final URIResolver resolver, final Model model) {
        final XsltExecutable load = this.repository.load(uri, resolver);
        return transform(Transform.create(load).build(), model);
    }

    public <T> Result<T, SyntaxError> transform(final Transform<T> transform, final Model model) {
        log.debug("Start transformation");
        return transform(transform, model, Collections.EMPTY_MAP);
    }

    public <T> Result<T, SyntaxError> transform(final Transform<T> transform, final Model model, final Map<QName, XdmValue> parameters) {
        final Result<T, SyntaxError> result = runTransformation(transform, model, parameters);
        if (transform.getSchema() != null) {
            this.schemaValidationService.validate(transform.getSchema(), result.getObject());
        }
        return result;
    }

    private <T> Result<T, SyntaxError> runTransformation(final Transform<T> transform, final Model model, final Map<QName, XdmValue> parameters) {
        try (InputStream modelInput = new ByteArrayInputStream(model.getMain().getContent())) {
            final StreamSource source = new StreamSource(modelInput);
            final Transform<T> t = Transform.extend(transform).useResolver(new InMemoryResolver(model.getReferences())).withParams(parameters).build();
            return execute(t, source, createConvert(t));
        } catch (final IOException e) {
            log.error("Error transforming model", e);
            throw new CommonException(ErrorCode.TRANSFORMATION_ERROR, e.getMessage(), e);
        }
    }

    private <T> Result<T, SyntaxError> execute(final Transform<T> transform, final Source source, final Convert<T> convert) {
        log.debug("Run actual transformation");
        final CollectingErrorEventHandler errorEventHandler = new CollectingErrorEventHandler();
        try {
            final DocumentBuilder documentBuilder = this.processor.newDocumentBuilder();
            log.debug("Documetbuilder class {} ", documentBuilder.getClass().getCanonicalName());
            final XdmNode xdmSource = documentBuilder.build(source);
            final XsltTransformer transformer = transform.getExecutable().load();
            transformer.setInitialContextNode(xdmSource);
            transformer.setMessageListener(errorEventHandler);
            transform.getParameters().forEach(transformer::setParameter);
            transformer.setURIResolver(transform.getResolver());
            transformer.setDestination(convert.createDestination());
            log.debug("Start transform");
            transformer.transform();
            log.debug("End transform");
            final List<SyntaxError> warnings = errorEventHandler.getErrors().stream().filter(e -> e.getSeverity() == Severity.SEVERITY_WARNING).collect(Collectors.toList());
            final List<SyntaxError> errors = errorEventHandler.getErrors().stream().filter(e -> e.getSeverity() != Severity.SEVERITY_WARNING).collect(Collectors.toList());
            if (transform.getSchema() != null) {
                final Result<Boolean, SyntaxError> validationResult = this.schemaValidationService.validate(transform.getSchema(), convert.getResult());
                if (validationResult.isInvalid()) {
                    errors.addAll(validationResult.getErrors());
                }
            }
            return new Result<>(convert.getResult(), warnings, errors);
        } catch (final SaxonApiException e) {
            String msg = e.getMessage();
            if (errorEventHandler.hasErrors()) {
                final List<SyntaxError> errors = errorEventHandler.getErrors();
                msg = errors.get(errors.size() - 1).getMessage();
            }
            msg = msg.replaceAll("\\$", "");
            throw new TransformException(new BusinessError(ErrorCode.TRANSFORMATION_ERROR, msg), e);
        }
    }

    @SuppressWarnings("unchecked")
    private <T> Convert<T> createConvert(final Transform<T> transform) {
        final Class<T> targetType = transform.getTargetType();
        if (byte[].class.isAssignableFrom(targetType)) {
            return (Convert<T>) new ByteArrayConvert();
        }
        if (Document.class.isAssignableFrom(targetType)) {
            return (Convert<T>) new DocumentConvert();
        }
        return new ObjektConvert<>(conversionService, targetType, transform.getUnmarshListener());
    }

    public <T> Result<T, SyntaxError> transform(final Transform<T> t, final Document document) {
        return execute(t, new DOMSource(document), createConvert(t));
    }

    @java.lang.SuppressWarnings("all")
    public TransformationService(final ConversionService conversionService, final SchemaValidationService schemaValidationService, final ExecutableRepository repository, final Processor processor) {
        this.conversionService = conversionService;
        this.schemaValidationService = schemaValidationService;
        this.repository = repository;
        this.processor = processor;
    }

    @java.lang.SuppressWarnings("all")
    public TransformationService() {
    }
}
